#version 450
#extension GL_GOOGLE_include_directive : enable

#include "../../include/struct.glsl"

layout (local_size_x = 8, local_size_y = 8) in;

layout (set = 0, binding = 0) uniform ShadowDataBuffer {
	ShadowData shadowData;
};

layout(set = 0, binding = 2) buffer TrianglesBuffer {
	TriangleData triangles[];
} trianglesBuffer[3];

layout(set = 0, binding = 2) buffer GridSizeBuffer {
	uint grid[];
} gridSizeBuffer[3];

layout(set = 0, binding = 2) buffer GridIndexesBuffer {
	uint index[];
} gridIndexBuffer[3];

layout(set = 0, binding = 3, r16) uniform writeonly image2D sdfImage;

float intersectTriangle(in vec2 p, uint idx) {
	TriangleData t = trianglesBuffer[0].triangles[idx];
	return (triangle2d(p, t.a, t.b, t.c) < -0.5 * shadowData.density) ? trianglesBuffer[0].triangles[idx].value : 0.0;
}

float intersect(in uint cellIdx, in vec2 coord) {
	float value = 0.0;

	uint targetOffset = cellIdx * shadowData.trianglesCount;
	for (uint i = 0; i < gridSizeBuffer[1].grid[cellIdx]; ++ i) {
		value = max(value, intersectTriangle(coord, gridIndexBuffer[2].index[targetOffset + i]));
	}
	return value;
}

void main() {
	ivec2 imgSize = imageSize(sdfImage);
	vec2 rel = vec2(float(gl_GlobalInvocationID.x) / float(imgSize.x - 1), float(gl_GlobalInvocationID.y - 1) / float(imgSize.y));
	vec2 coords = (vec2(float(gl_GlobalInvocationID.x) + 0.5, float(gl_GlobalInvocationID.y) + 0.5))
			* shadowData.shadowSdfDensity
			- shadowData.shadowOffset * rel 
			//* shadowData.shadowSdfDensity + shadowData.shadowOffset * rel
			;

	uvec2 cellIdxs = uvec2(floor(coords)) / shadowData.gridSize;
	uint cellIdx = cellIdxs.y * (shadowData.gridWidth) + cellIdxs.x;

	uint targetOffset = cellIdx * shadowData.trianglesCount;
	uint nTriangles = gridSizeBuffer[1].grid[cellIdx];

	vec3 coords3d = vec3(coords, intersect(cellIdx, coords));
	float value = 128.0;
	float sdf;
	float height;

	for (uint i = 0; i < nTriangles; ++ i) {
		TriangleData t = trianglesBuffer[0].triangles[gridIndexBuffer[2].index[targetOffset + i]];
		sdf = triangle3d(coords3d, t.a, t.b, t.c, t.value);

		if (sdf < value) {
			value = sdf;
			height = t.value;
		}
	}

	imageStore(sdfImage, ivec2(gl_GlobalInvocationID.x, imgSize.y - gl_GlobalInvocationID.y - 1), vec4(value, height, 0.0, 0.0));
}

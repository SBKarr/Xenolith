/**
 Copyright (c) 2022 Roman Katuntsev <sbkarr@stappler.org>

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 **/


#include "SPCommon.h"
#include "SPBitmap.h"
#include "SPSql.h"
#include "SPFilesystem.h"
#include "SPTime.h"
#include "SPHtmlParser.h"
#include "SPNetworkHandle.h"
#include "SPSpanView.h"

static constexpr auto HELP_STRING(
R"HelpString(headergen <options> <command>
Options:
    -v (--verbose)
    -h (--help))HelpString");

static constexpr auto FILE_HEADER_STRING(
R"HeaderString(/**
 Copyright (c) 2022 Roman Katuntsev <sbkarr@stappler.org>

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 **/

// Autogenerated with 'headergen' script
)HeaderString");

static constexpr auto SOURCE_PREDEFINED_FUNCTIONS(
R"SourceString(
#if VK_HOOK_DEBUG

struct InstanceTableHookInfo {
	void (*preCall) (void *, const char *, PFN_vkVoidFunction);
	void (*postCall) (void *, const char *, PFN_vkVoidFunction);
	const InstanceTable *table;
	const InstanceTable *replace;
	void *ctx;
};

struct DeviceTableHookInfo {
	void (*preCall) (void *, const char *, PFN_vkVoidFunction);
	void (*postCall) (void *, const char *, PFN_vkVoidFunction);
	const DeviceTable *table;
	const DeviceTable *replace;
	void *ctx;
};

thread_local InstanceTableHookInfo tl_instanceHookTable;
thread_local DeviceTableHookInfo tl_deviceHookTable;

void setInstanceHookThreadContext(
		void (*pre) (void *, const char *, PFN_vkVoidFunction),
		void (*post) (void *, const char *, PFN_vkVoidFunction),
		const InstanceTable *t, const InstanceTable *r, void *c) {
	tl_instanceHookTable.preCall = pre;
	tl_instanceHookTable.postCall = post;
	tl_instanceHookTable.table = t;
	tl_instanceHookTable.replace = r;
	tl_instanceHookTable.ctx = c;
}

void setDeviceHookThreadContext(
		void (*pre) (void *ctx, const char *, PFN_vkVoidFunction),
		void (*post) (void *ctx, const char *, PFN_vkVoidFunction),
		const DeviceTable *t, const DeviceTable *r, void *c) {
	tl_deviceHookTable.preCall = pre;
	tl_deviceHookTable.postCall = post;
	tl_deviceHookTable.table = t;
	tl_deviceHookTable.replace = r;
	tl_deviceHookTable.ctx = c;
}

#endif /* VK_HOOK_DEBUG */

static PFN_vkVoidFunction loadInstanceAliased(PFN_vkGetInstanceProcAddr addr, VkInstance instance, const char *name,
		std::initializer_list<const char *> aliases) {
	auto ret = addr(instance, name);
	if (!ret) {
		for (auto it : aliases) {
			ret = addr(instance, it);
		}
	}
	return ret;
}

static PFN_vkVoidFunction loadDeviceAliased(PFN_vkGetDeviceProcAddr addr, VkDevice instance, const char *name,
		std::initializer_list<const char *> aliases) {
	auto ret = addr(instance, name);
	if (!ret) {
		for (auto it : aliases) {
			ret = addr(instance, it);
		}
	}
	return ret;
})SourceString");

static constexpr auto SOURCE_PREDEFINED_PROTO(
R"SourceString(
#if VK_HOOK_DEBUG
void setInstanceHookThreadContext(
		void (*preCall) (void *, const char *, PFN_vkVoidFunction),
		void (*postCall) (void *, const char *, PFN_vkVoidFunction),
		const InstanceTable *table, const InstanceTable *replace, void *ctx);

void setDeviceHookThreadContext(
		void (*preCall) (void *, const char *, PFN_vkVoidFunction),
		void (*postCall) (void *, const char *, PFN_vkVoidFunction),
		const DeviceTable *table, const DeviceTable *replace, void *ctx);
#endif
)SourceString");

namespace stappler::xenolith::headergen {

struct VkRegistryCommandProto {
	Vector<StringView> strings;
	StringView type;
	StringView name;
};

struct VkRegistryCommand {
	Vector<StringView> successcodes;
	Vector<StringView> errorcodes;

	VkRegistryCommandProto proto;
	Vector<VkRegistryCommandProto> params;

	StringView name;
	StringView alias;

	VkRegistryCommand *canonical = nullptr;
	Vector<StringView> aliases;

	StringView rootType;
	Vector<Pair<StringView, StringView>> requires;
	String guard;
};

struct VkRegistryType {
	StringView alias;
	StringView name;
	StringView parent;
	StringView category;

	VkRegistryType *parentType = nullptr;
	VkRegistryType *canonical = nullptr;
	Vector<StringView> aliases;
};

struct VkRegistryRequire {
	StringView extension;
	StringView feature;
	Vector<StringView> commands;
};

struct VkRegistryFeature {
	StringView name;
	Vector<VkRegistryRequire> requires;
};

struct VkRegistryExtension {
	StringView name;
	StringView type;
	StringView supported;
	Vector<StringView> requires;
	Vector<VkRegistryRequire> commands;
};

struct VkRegistryReaderTag : public html::Tag<StringView> {
	VkRegistryReaderTag(const StringView &name) : Tag(name) { }

	VkRegistryType *type = nullptr;
	VkRegistryCommand *command = nullptr;
	VkRegistryCommandProto *proto = nullptr;
	VkRegistryFeature *feature = nullptr;
	VkRegistryRequire *require = nullptr;
	VkRegistryExtension *extension = nullptr;
	StringView *string = nullptr;
};

struct VkRegistryReader {
	using Parser = html::Parser<VkRegistryReader, StringView, VkRegistryReaderTag>;
	using Tag = VkRegistryReaderTag;

	enum Section {
		None,
		Types,
		Commands,
		Feature,
		Extensions,
	};

	inline void onBeginTag(Parser &p, Tag &tag) {
		switch (_section) {
		case Section::None:
			if (tag.name == "feature") {
				auto &v = _features.emplace_back(VkRegistryFeature());
				tag.feature = &v;
			}
			break;
		case Section::Types:
			if (tag.name == "type" && p.tagStack.back().type == nullptr) {
				auto &v = _types.emplace_back(VkRegistryType());
				tag.type = &v;
			}
			break;
		case Section::Commands:
			if (tag.name == "command") {
				auto &v = _commands.emplace_back(VkRegistryCommand());
				tag.command = &v;
			}
			break;
		case Section::Feature:
			if (tag.name == "require") {
				auto &v = p.tagStack.back().feature->requires.emplace_back(VkRegistryRequire());
				tag.require = &v;
			} else if (tag.name == "command" && p.tagStack.back().require) {
				auto v = &p.tagStack.back().require->commands.emplace_back(StringView());
				tag.string = v;
			}
			break;
		case Section::Extensions:
			if (tag.name == "extension") {
				auto &v = _extensions.emplace_back(VkRegistryExtension());
				tag.extension = &v;
			} else if (tag.name == "require") {
				auto &v = p.tagStack.back().extension->commands.emplace_back(VkRegistryRequire());
				tag.require = &v;
			} else if (tag.name == "command" && p.tagStack.back().require) {
				auto v = &p.tagStack.back().require->commands.emplace_back(StringView());
				tag.string = v;
			}
			break;
		}
		// log::text("onBeginTag", tag.name);
	}

	inline void onEndTag(Parser &p, Tag &tag, bool isClosable) {
		// log::text("onEndTag", tag.name);
	}

	inline void onTagAttribute(Parser &p, Tag &tag, StringView &name, StringView &value) {
		if (tag.name == "command" && tag.command) {
			if (name == "successcodes") {
				value.split<StringView::Chars<','>>([&] (StringView str) {
					tag.command->successcodes.emplace_back(str);
				});
			} else if (name == "errorcodes") {
				value.split<StringView::Chars<','>>([&] (StringView str) {
					tag.command->errorcodes.emplace_back(str);
				});
			} else if (name == "name") {
				tag.command->name = value;
			} else if (name == "alias") {
				tag.command->alias = value;
			}
		} else if (tag.name == "command" && tag.string && name == "name") {
			*tag.string = value;
		} else if (tag.name == "type" && tag.type) {
			if (name == "category") {
				tag.type->category = value;
			} else if (name == "parent") {
				tag.type->parent = value;
			} else if (name == "alias") {
				tag.type->alias = value;
			} else if (name == "name") {
				tag.type->name = value;
			}
		} else if (tag.name == "feature" && name == "name") {
			tag.feature->name = value;
		} else if (tag.name == "require" && tag.require) {
			if (name == "extension") {
				tag.require->extension = value;
			} else if (name == "feature") {
				tag.require->feature = value;
			}
		} else if (tag.name == "extension" && tag.extension) {
			if (name == "name") {
				tag.extension->name = value;
			} else if (name == "supported") {
				tag.extension->supported = value;
			} else if (name == "type") {
				tag.extension->type = value;
			} else if (name == "requires") {
				value.split<StringView::Chars<','>>([&] (StringView v) {
					tag.extension->requires.emplace_back(v);
				});
			}
		}
		// log::vtext("onTagAttribute", tag.name, ": ", name, " = ", value);
	}

	inline void onPushTag(Parser &p, Tag &tag) {
		if (_section == None) {
			if (tag.name == "commands" && _section == None) {
				_section = Commands;
			} else if (tag.name == "types" && _section == None) {
				_section = Types;
			} else if (tag.name == "feature" && _section == None) {
				_section = Feature;
			} else if (tag.name == "extensions" && _section == None) {
				_section = Extensions;
			}
		} else if (tag.name == "proto") {
			tag.proto = &p.tagStack.back().command->proto;
		} else if (tag.name == "param" && p.tagStack.back().command) {
			tag.proto = &p.tagStack.back().command->params.emplace_back(VkRegistryCommandProto());
		} else if (tag.name == "type" && p.tagStack.back().proto) {
			auto str = &p.tagStack.back().proto->strings.emplace_back(StringView());
			tag.string = str;
		} else if (tag.name == "name" && p.tagStack.back().proto) {
			auto str = &p.tagStack.back().proto->strings.emplace_back(StringView());
			tag.string = str;
		} else if (tag.name == "name" && p.tagStack.back().type) {
			tag.string = &p.tagStack.back().type->name;
		}
	}

	inline void onPopTag(Parser &p, Tag &tag) {
		if (tag.name == "commands" && _section == Commands) {
			_section = None;
		} else if (tag.name == "types" && _section == Types) {
			_section = None;
		} else if (tag.name == "feature" && _section == Feature) {
			_section = None;
		} else if (tag.name == "extensions" && _section == Extensions) {
			_section = None;
		} else if (tag.name == "command" && tag.command) {
			tag.command->name = tag.command->proto.name;
		} else if (tag.string && tag.name == "name" && p.tagStack.at(p.tagStack.size() - 2).proto) {
			p.tagStack.at(p.tagStack.size() - 2).proto->name = *tag.string;
		} else if (tag.string && tag.name == "type" && p.tagStack.at(p.tagStack.size() - 2).proto) {
			p.tagStack.at(p.tagStack.size() - 2).proto->type = *tag.string;
		}
		// log::text("onPopTag", tag.name);
	}

	inline void onInlineTag(Parser &p, Tag &tag) {
		// log::text("onInlineTag", tag.name);
	}

	inline void onTagContent(Parser &p, Tag &tag, StringView &s) {
		if ((tag.name == "proto" || tag.name == "param") && tag.proto) {
			tag.proto->strings.emplace_back(normalizeString(s));
		} else if (tag.string) {
			*tag.string = normalizeString(s);
		}
		// log::vtext("onTagContent", tag.name, ": ", s);
	}

	StringView normalizeString(StringView s) {
		auto tmp = s; tmp.trimChars<StringView::WhiteSpace>();
		if (tmp.empty()) {
			return StringView(" ");
		} else if (tmp == "*") {
			return StringView("* ");
		} else {
			return s;
		}
	}

	Section _section = None;
	Vector<VkRegistryCommand> _commands;
	Vector<VkRegistryType> _types;
	Vector<VkRegistryFeature> _features;
	Vector<VkRegistryExtension> _extensions;
};

int parseOptionSwitch(data::Value &ret, char c, const char *str) {
	if (c == 'h') {
		ret.setBool(true, "help");
	} else if (c == 'v') {
		ret.setBool(true, "verbose");
	}
	return 1;
}

int parseOptionString(data::Value &ret, const StringView &str, int argc, const char * argv[]) {
	if (str == "help") {
		ret.setBool(true, "help");
	} else if (str == "verbose") {
		ret.setBool(true, "verbose");
	} else if (str == "gencbor") {
		ret.setBool(true, "gencbor");
	}
	return 1;
}

struct RegistryData {
	bool load() {
		NetworkHandle h;
		h.init(NetworkHandle::Method::Get, "https://raw.githubusercontent.com/KhronosGroup/Vulkan-Docs/main/xml/vk.xml");

		h.setReceiveCallback([&] (char *d, size_t len) {
			data << StringView(d, len);
			return len;
		});

		if (h.perform()) {
			parse();
			return true;
		}
		return false;
	}

	StringView getRootType(VkRegistryCommand &cmd) {
		if (cmd.name == "vkGetInstanceProcAddr") {
			return StringView();
		} else if (cmd.name == "vkGetDeviceProcAddr") {
			return StringView("VkInstance");
		}

		if (!cmd.params.empty()) {
			auto type = cmd.params.at(0).type;
			auto it = types.find(type);
			if (it != types.end()) {
				auto ret = &it->second;
				while (ret->canonical) {
					ret = ret->canonical;
				}

				while (ret->name != "VkInstance" && ret->name != "VkDevice" && ret->parentType) {
					ret = ret->parentType;
				}

				return ret->name;
			}
		}
		return StringView();
	}

	VkRegistryCommand *getCommand(StringView cmd) {
		VkRegistryCommand *ptr = nullptr;
		auto it = commands.find(cmd);
		if (it != commands.end()) {
			ptr = &it->second;
		}
		return ptr;
	}

	void parse() {
		VkRegistryReader reader;
		html::parse<VkRegistryReader, StringView, VkRegistryReaderTag>(reader, StringView(data.data(), data.size()), true, false);

		for (auto &it : reader._types) {
			if (it.category == "handle" || it.category == "struct" || it.category == "bitmask") {
				types.emplace(it.name, it);
			}
		}

		for (auto &it : types) {
			if (!it.second.parent.empty()) {
				auto v = types.find(it.second.parent);
				if (v != types.end()) {
					it.second.parentType = &v->second;
				}
			}
			if (!it.second.alias.empty()) {
				auto v = types.find(it.second.alias);
				if (v != types.end()) {
					it.second.canonical = &v->second;
					while (it.second.canonical->canonical) {
						it.second.canonical = it.second.canonical->canonical;
					}
					it.second.canonical->aliases.emplace_back(it.second.name);
				}
			}
		}

		for (auto &it : reader._commands) {
			commands.emplace(it.name, it);
		}

		for (auto &it : commands) {
			if (!it.second.alias.empty()) {
				auto v = commands.find(it.second.alias);
				if (v != commands.end()) {
					it.second.canonical = &v->second;
					while (it.second.canonical->canonical) {
						it.second.canonical = it.second.canonical->canonical;
					}
					it.second.canonical->aliases.emplace_back(it.second.name);
					it.second.rootType = getRootType(*it.second.canonical);
				}
			} else {
				it.second.rootType = getRootType(it.second);
			}
		}

		features = move(reader._features);
		extensions = move(reader._extensions);

		for (auto &ext : extensions) {
			if (ext.supported == "disabled") {
				continue;
			}
			for (auto &req : ext.commands) {
				for (auto &c : req.commands) {
					auto it = commands.find(c);
					if (it != commands.end()) {
						if (!req.feature.empty()) {
							it->second.requires.emplace_back(ext.name, req.feature);
						}
						if (!req.extension.empty()) {
							it->second.requires.emplace_back(ext.name, req.extension);
						}
					}
				}
			}
		}
	}

	String makeGuard(StringView name, SpanView<Pair<StringView, StringView>> reqs) {
		StringStream out;
		if (reqs.empty()) {
			out << "defined(" << name << ")";
		} else if (reqs.size() == 1) {
			auto &tmp = reqs.front();
			out << "defined(" << tmp.first << ") && defined(" << tmp.second << ")";
		} else {
			bool first = true;
			for (auto &req : reqs) {
				if (first) { first = false; } else { out << " || "; }
				out << "(defined(" << req.first << ") && defined(" << req.second << "))";
			}
		}
		return out.str();
	}

	void writeCommandFields(std::ostream &out, StringView guard, SpanView<StringView> commands) {
		if (commands.empty()) {
			return;
		}
		out << "#if " << guard << "\n";
		for (auto &it : commands) {
			out << "\tconst PFN_" << it << " " << it << " = nullptr;\n";
		}
		out << "#endif /* " << guard << " */\n";
	}

	void writeLoaderConstructor(std::ostream &out, StringView guard, SpanView<StringView> commands) {
		if (commands.empty()) {
			return;
		}
		out << "#if " << guard << "\n";
		for (auto &it : commands) {
			if (it == "vkGetInstanceProcAddr") {
				out << ": " << it << "(addr)\n";
			} else {
				out << ", " << it << "((PFN_" << it << ")addr(nullptr, \"" << it << "\"))\n";
			}
		}
		out << "#endif /* " << guard << " */\n";
	}

	void writeInstanceConstructor(std::ostream &out, StringView guard, SpanView<StringView> commands) {
		if (commands.empty()) {
			return;
		}
		out << "#if " << guard << "\n";
		for (auto &it : commands) {
			if (it == "vkGetInstanceProcAddr") {
				out << ": " << it << "(addr)\n";
			} else {
				auto cmd = getCommand(it);
				while (cmd->canonical) {
					cmd = cmd->canonical;
				}

				if (cmd->aliases.empty()) {
					out << ", " << it << "((PFN_" << it << ")addr(instance, \"" << it << "\"))\n";
				} else {
					out << ", " << it << "((PFN_" << it << ")loadInstanceAliased(addr, instance, \"" << cmd->name << "\", {";
					bool first = true;
					for (auto &it : cmd->aliases) {
						if (first) { first = false; } else { out << ", "; }
						out << "\"" << it << "\"";
					}
					out << "}))\n";
				}
			}
		}
		out << "#endif /* " << guard << " */\n";
	}

	void writeDeviceConstructor(std::ostream &out, StringView guard, SpanView<StringView> commands) {
		if (commands.empty()) {
			return;
		}
		out << "#if " << guard << "\n";
		for (auto &it : commands) {
			if (it == "vkGetDeviceProcAddr") {
				out << ": " << it << "(addr)\n";
			} else {
				auto cmd = getCommand(it);
				while (cmd->canonical) {
					cmd = cmd->canonical;
				}

				if (cmd->aliases.empty()) {
					out << ", " << it << "((PFN_" << it << ")addr(device, \"" << it << "\"))\n";
				} else {
					out << ", " << it << "((PFN_" << it << ")loadDeviceAliased(addr, device, \"" << cmd->name << "\", {";
					bool first = true;
					for (auto &it : cmd->aliases) {
						if (first) { first = false; } else { out << ", "; }
						out << "\"" << it << "\"";
					}
					out << "}))\n";
				}
			}
		}
		out << "#endif /* " << guard << " */\n";
	}

	void writeHooks(std::ostream &out, StringView guard, SpanView<StringView> commands, StringView ctx) {
		if (commands.empty()) {
			return;
		}

		out << "#if " << guard << "\n\n";

		for (auto &it : commands) {
			bool aliased = false;

			auto cmd = getCommand(it);
			while (cmd->canonical) {
				cmd = cmd->canonical;
				aliased = true;
			}

			StringView tag;

			out << "static ";
			for (auto &v : cmd->proto.strings) {
				if (v == cmd->name) {
					out << "xl_hook_" << ctx << "_" << it;
					if (v != it) {
						if (v.size() > it.size()) {
							tag = StringView(v.data() + it.size(), v.size() - it.size());
						} else {
							tag = StringView(it.data() + v.size(), it.size() - v.size());
						}
					}
				} else {
					out << v;
				}
			}

			out << "(";
			bool first = true;
			for (auto &param : cmd->params) {
				if (first) { first = false; } else { out << ", "; }
				for (auto &v : param.strings) {
					if (v == param.type && aliased) {
						auto vIt = types.find(v);
						if (vIt != types.end()) {
							if (vIt->second.aliases.empty()) {
								out << v;
							} else if (vIt->second.aliases.size() == 1) {
								out << vIt->second.aliases.front();
							} else {
								bool found = false;
								for (auto &n : vIt->second.aliases) {
									if (n.ends_with(tag)) {
										out << n;
										found = true;
										break;
									}
								}
								if (!found) {
									out << v;
								}
							}
						} else {
							out << v;
						}
					} else {
						out << v;
					}
				}
			}
			out << ") {\n"
			"\tauto __fn = " << ctx << ".table->" << it << ";\n"
			"\tif (" << ctx << ".replace && " << ctx << ".replace->" << it << ") {\n"
			"\t\t__fn = " << ctx << ".replace->" << it << ";\n"
			"\t}\n"
			"\tif (" << ctx << ".preCall) { " << ctx << ".preCall(" << ctx << ".ctx, \"" << it << "\", (PFN_vkVoidFunction)__fn); }\n";
			if (cmd->proto.type != "void") {
				out << "\tauto ret = __fn(";
				first = true;
				for (auto &param : cmd->params) {
					if (first) { first = false; } else { out << ", "; }
					out << param.name;
				}
				out << ");\n";
				out << "\tif (" << ctx << ".postCall) { " << ctx << ".postCall(" << ctx << ".ctx, \"" << it << "\", (PFN_vkVoidFunction)__fn); }\n";
				out << "\treturn ret;\n";
			} else {
				out << "\t__fn(";
				first = true;
				for (auto &param : cmd->params) {
					if (first) { first = false; } else { out << ", "; }
					out << param.name;
				}
				out << ");\n";
				out << "\tif (" << ctx << ".postCall) { " << ctx << ".postCall(" << ctx << ".ctx, \"" << it << "\", (PFN_vkVoidFunction)__fn); }\n";
			}

			out << "}\n\n";
		}

		out << "#endif /* " << guard << " */\n\n";
	}

	void writeHooksAddr(std::ostream &out, StringView guard, SpanView<StringView> commands, StringView ctx) {
		if (commands.empty()) {
			return;
		}

		out << "#if " << guard << "\n";

		for (auto &it : commands) {
			out << "\tif (strcmp(pName, \"" << it << "\") == 0) { return (PFN_vkVoidFunction)&xl_hook_" << ctx << "_" << it << "; }\n";
		}

		out << "#endif /* " << guard << " */\n";
	}

	void write() {
		Set<StringView> writtenLoader;
		Set<StringView> writtenInstance;
		Set<StringView> writtenDevice;

		memory::ostringstream loaderHeader;
		memory::ostringstream instanceHeader;
		memory::ostringstream deviceHeader;

		memory::ostringstream loaderConstructor;
		memory::ostringstream instanceConstructor;
		memory::ostringstream deviceConstructor;

		memory::ostringstream instanceHooks;
		memory::ostringstream deviceHooks;

		memory::ostringstream instanceHooksAddr;
		memory::ostringstream deviceHooksAddr;

		for (auto &feature : features) {
			auto guard = toString("defined(", feature.name, ")");

			Vector<StringView> deviceCmds;
			Vector<StringView> instanceCmds;
			Vector<StringView> loaderCmds;

			if (feature.name == "VK_VERSION_1_0") {
				// reorder vkGetInstanceProcAddr for constructor
				loaderCmds.emplace_back("vkGetInstanceProcAddr");
				instanceCmds.emplace_back("vkGetInstanceProcAddr");
				deviceCmds.emplace_back("vkGetDeviceProcAddr");
			}

			for (auto &req : feature.requires) {
				for (auto &c : req.commands) {
					auto cmd = getCommand(c);

					auto list = &writtenLoader;
					auto cmds = &loaderCmds;
					if (cmd->rootType == "VkDevice") {
						cmds = &deviceCmds; list = &writtenDevice;
					} else if (cmd->rootType == "VkInstance") {
						cmds = &instanceCmds; list = &writtenInstance;
					}

					if (c != "vkGetInstanceProcAddr") {
						auto iit = list->find(c);
						if (iit == list->end()) {
							cmds->emplace_back(c);
							list->emplace(c);
						}
					}
					cmd->guard = guard;
				}
			}

			writeCommandFields(deviceHeader, guard, deviceCmds);
			writeCommandFields(instanceHeader, guard, instanceCmds);
			writeCommandFields(loaderHeader, guard, loaderCmds);
			writeLoaderConstructor(loaderConstructor, guard, loaderCmds);
			writeInstanceConstructor(instanceConstructor, guard, instanceCmds);
			writeDeviceConstructor(deviceConstructor, guard, deviceCmds);

			writeHooks(instanceHooks, guard, instanceCmds, "tl_instanceHookTable");
			writeHooks(deviceHooks, guard, deviceCmds, "tl_deviceHookTable");
			writeHooksAddr(instanceHooksAddr, guard, instanceCmds, "tl_instanceHookTable");
			writeHooksAddr(deviceHooksAddr, guard, deviceCmds, "tl_deviceHookTable");
		}

		for (auto &ext : extensions) {
			if (ext.supported == "disabled") {
				continue;
			}

			Map<SpanView<Pair<StringView, StringView>>, Vector<StringView>> deviceCmds;
			Map<SpanView<Pair<StringView, StringView>>, Vector<StringView>> instanceCmds;

			for (auto &req : ext.commands) {
				for (auto &c : req.commands) {
					auto cmd = getCommand(c);

					auto list = &writtenInstance;
					auto cmds = &instanceCmds;
					if (cmd->rootType == "VkDevice" && ext.type != "instance") {
						cmds = &deviceCmds; list = &writtenDevice;
					}

					auto v = cmds->find(makeSpanView(cmd->requires));
					if (v == cmds->end()) {
						v = cmds->emplace(makeSpanView(cmd->requires), Vector<StringView>()).first;
					}

					auto iit = list->find(c);
					if (iit == list->end()) {
						v->second.emplace_back(c);
						list->emplace(c);
					}
					cmd->guard = makeGuard(ext.name, cmd->requires);
				}
			}

			for (auto &cmd : deviceCmds) {
				auto guard =  makeGuard(ext.name, cmd.first);
				writeCommandFields(deviceHeader, guard, cmd.second);
				writeDeviceConstructor(deviceConstructor, guard, cmd.second);
				writeHooks(deviceHooks, guard, cmd.second, "tl_deviceHookTable");
				writeHooksAddr(deviceHooksAddr, guard, cmd.second, "tl_deviceHookTable");
			}
			for (auto &cmd : instanceCmds) {
				auto guard =  makeGuard(ext.name, cmd.first);
				writeCommandFields(instanceHeader, guard, cmd.second);
				writeInstanceConstructor(instanceConstructor, guard, cmd.second);
				writeHooks(instanceHooks, guard, cmd.second, "tl_instanceHookTable");
				writeHooksAddr(instanceHooksAddr, guard, cmd.second, "tl_instanceHookTable");
			}
		}

		std::cout << "--- LOADER ---\n" << loaderHeader.weak() << "\n";
		std::cout << "--- INSTANCE ---\n" << instanceHeader.weak() << "\n";
		std::cout << "--- DEVICE ---\n" << deviceHeader.weak() << "\n";

		auto headerPath = filesystem::currentDir("gen/XLVkTable.h");
		filesystem::mkdir(filepath::root(headerPath));
		filesystem::remove(headerPath);

		std::ofstream headerFile(headerPath.data());
		headerFile << FILE_HEADER_STRING
			<< "\n#ifndef COMPONENTS_XENOLITH_VK_XLVKTABLE_H_\n#define COMPONENTS_XENOLITH_VK_XLVKTABLE_H_\n\n"
					"namespace stappler::xenolith::vk {\n\n"
			<< "struct LoaderTable {\n"
					"\tLoaderTable(PFN_vkGetInstanceProcAddr addr);\n\n" << loaderHeader.weak() << "};\n\n"
			<< "struct InstanceTable {\n"
					"#if VK_HOOK_DEBUG\n\tstatic InstanceTable makeHooks();\n#endif /* VK_HOOK_DEBUG */\n\n"
					"\tInstanceTable(PFN_vkGetInstanceProcAddr addr, VkInstance instance);\n\n" << instanceHeader.weak() << "};\n\n"
			<< "struct DeviceTable {\n"
					"#if VK_HOOK_DEBUG\n\tstatic DeviceTable makeHooks();\n#endif /* VK_HOOK_DEBUG */\n\n"
					"\tDeviceTable(PFN_vkGetDeviceProcAddr addr, VkDevice device);\n\n" << deviceHeader.weak() << "};\n"
			<< SOURCE_PREDEFINED_PROTO
			<< "\n}\n\n#endif // COMPONENTS_XENOLITH_VK_XLVKTABLE_H_\n";

		auto sourcePath = filesystem::currentDir("gen/XLVkTable.cc");
		filesystem::mkdir(filepath::root(sourcePath));
		filesystem::remove(sourcePath);

		std::ofstream sourceFile(sourcePath.data());
		sourceFile << FILE_HEADER_STRING
			<< "\nnamespace stappler::xenolith::vk {\n" << SOURCE_PREDEFINED_FUNCTIONS << "\n\n"
			<< "LoaderTable::LoaderTable(PFN_vkGetInstanceProcAddr addr)\n" << loaderConstructor.weak() << "{ }\n\n"
			<< "InstanceTable::InstanceTable(PFN_vkGetInstanceProcAddr addr, VkInstance instance)\n" << instanceConstructor.weak() << "{ }\n\n"
			<< "DeviceTable::DeviceTable(PFN_vkGetDeviceProcAddr addr, VkDevice device)\n" << deviceConstructor.weak() << "{ }\n\n"
			<< "#if VK_HOOK_DEBUG\n"
			<< instanceHooks.weak()
			<< deviceHooks.weak()
			<< "\nstatic PFN_vkVoidFunction getInstanceHookAddr(VkInstance instance, const char* pName) {\n"
			<< instanceHooksAddr.weak()
			<< "\treturn nullptr;\n}\n\n"
			<< "\nstatic PFN_vkVoidFunction getDeviceHookAddr(VkDevice instance, const char* pName) {\n"
			<< deviceHooksAddr.weak()
			<< "\treturn nullptr;\n}\n\n"
			<< "InstanceTable InstanceTable::makeHooks() {\n\treturn InstanceTable(&getInstanceHookAddr, nullptr);\n}\n\n"
			<< "DeviceTable DeviceTable::makeHooks() {\n\treturn DeviceTable(&getDeviceHookAddr, nullptr);\n}\n\n"
			<< "#endif /* VK_HOOK_DEBUG */\n\n"
			<< "}\n";
	}

	Map<StringView, VkRegistryType> types;
	Map<StringView, VkRegistryCommand> commands;

	Vector<VkRegistryFeature> features;
	Vector<VkRegistryExtension> extensions;

	Vector<StringView> loaderCommands;
	Vector<StringView> instanceCommands;
	Vector<StringView> deviceCommands;

	memory::ostringstream data;
};

SP_EXTERN_C int _spMain(argc, argv) {
	data::Value opts = data::parseCommandLineOptions(argc, argv,
			&parseOptionSwitch, &parseOptionString);
	if (opts.getBool("help")) {
		std::cout << HELP_STRING << "\n";
		return 0;
	}

	if (opts.getBool("verbose")) {
		std::cout << " Current work dir: " << stappler::filesystem::currentDir() << "\n";
		std::cout << " Documents dir: " << stappler::filesystem::documentsPath() << "\n";
		std::cout << " Cache dir: " << stappler::filesystem::cachesPath() << "\n";
		std::cout << " Writable dir: " << stappler::filesystem::writablePath() << "\n";
		std::cout << " Options: " << stappler::data::EncodeFormat::Pretty << opts << "\n";
	}

	RegistryData registryData;
	if (registryData.load()) {
		registryData.write();
	}

	return 0;
}

}
